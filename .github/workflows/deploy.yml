name: Deploy

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to VPS via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT }}
          command_timeout: 30m
          script: |
            set -e
            echo "ðŸš€ Iniciando deploy..."
            
            cd /var/www/plataforma-servicios-ceres
            
            # Detectar IP del gateway de Docker para Redis
            DOCKER_GATEWAY_IP=$(docker network inspect bridge --format '{{range .IPAM.Config}}{{.Gateway}}{{end}}' 2>/dev/null || echo "172.17.0.1")
            echo "ðŸ” Gateway de Docker: $DOCKER_GATEWAY_IP"
            
            # Si existe un .env, hacer backup (el .env NO estÃ¡ en git, asÃ­ que no se borra con git reset)
            if [ -f .env ]; then
              echo "ðŸ“‹ Backup del .env existente..."
              cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
            fi
            
            # Pull cambios de Git PRIMERO
            echo "ðŸ“¥ Obteniendo cambios de Git..."
            git fetch origin main && git reset --hard origin/main
            
            # FunciÃ³n para actualizar o agregar variable en .env
            update_env_var() {
              local key=$1
              local value=$2
              if [ -f .env ] && grep -q "^${key}=" .env; then
                sed -i "s|^${key}=.*|${key}=${value}|" .env
              else
                echo "${key}=${value}" >> .env
              fi
            }
            
            # Actualizar variables desde GitHub Secrets
            echo "ðŸ“ Actualizando .env desde GitHub Secrets..."
            
            # Variables crÃ­ticas para build y runtime
            [ -n "${{ secrets.DATABASE_URL }}" ] && update_env_var "DATABASE_URL" "${{ secrets.DATABASE_URL }}"
            [ -n "${{ secrets.NEXTAUTH_URL }}" ] && update_env_var "NEXTAUTH_URL" "${{ secrets.NEXTAUTH_URL }}"
            [ -n "${{ secrets.NEXTAUTH_SECRET }}" ] && update_env_var "NEXTAUTH_SECRET" "${{ secrets.NEXTAUTH_SECRET }}"
            [ -n "${{ secrets.NEXT_PUBLIC_BASE_URL }}" ] && update_env_var "NEXT_PUBLIC_BASE_URL" "${{ secrets.NEXT_PUBLIC_BASE_URL }}"
            
            # SMTP
            [ -n "${{ secrets.SMTP_HOST }}" ] && update_env_var "SMTP_HOST" "${{ secrets.SMTP_HOST }}"
            [ -n "${{ secrets.SMTP_PORT }}" ] && update_env_var "SMTP_PORT" "${{ secrets.SMTP_PORT }}"
            [ -n "${{ secrets.SMTP_USER }}" ] && update_env_var "SMTP_USER" "${{ secrets.SMTP_USER }}"
            [ -n "${{ secrets.SMTP_PASS }}" ] && update_env_var "SMTP_PASS" "${{ secrets.SMTP_PASS }}"
            [ -n "${{ secrets.SMTP_FROM }}" ] && update_env_var "SMTP_FROM" "${{ secrets.SMTP_FROM }}"
            
            # Redis
            if [ -n "${{ secrets.REDIS_URL }}" ]; then
              update_env_var "REDIS_URL" "${{ secrets.REDIS_URL }}"
            elif [ ! -f .env ] || ! grep -q "^REDIS_URL=" .env; then
              update_env_var "REDIS_URL" "redis://${DOCKER_GATEWAY_IP}:6379/5"
            fi
            [ -n "${{ secrets.REDIS_PREFIX }}" ] && update_env_var "REDIS_PREFIX" "${{ secrets.REDIS_PREFIX }}"
            
            # OAuth y APIs
            [ -n "${{ secrets.GOOGLE_CLIENT_ID }}" ] && update_env_var "GOOGLE_CLIENT_ID" "${{ secrets.GOOGLE_CLIENT_ID }}"
            [ -n "${{ secrets.GOOGLE_CLIENT_SECRET }}" ] && update_env_var "GOOGLE_CLIENT_SECRET" "${{ secrets.GOOGLE_CLIENT_SECRET }}"
            [ -n "${{ secrets.FACEBOOK_CLIENT_ID }}" ] && update_env_var "FACEBOOK_CLIENT_ID" "${{ secrets.FACEBOOK_CLIENT_ID }}"
            [ -n "${{ secrets.FACEBOOK_CLIENT_SECRET }}" ] && update_env_var "FACEBOOK_CLIENT_SECRET" "${{ secrets.FACEBOOK_CLIENT_SECRET }}"
            [ -n "${{ secrets.ADMIN_API_KEY }}" ] && update_env_var "ADMIN_API_KEY" "${{ secrets.ADMIN_API_KEY }}"
            [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ] && update_env_var "SLACK_WEBHOOK_URL" "${{ secrets.SLACK_WEBHOOK_URL }}"
            [ -n "${{ secrets.QUEUES_UI_PASS }}" ] && update_env_var "QUEUES_UI_PASS" "${{ secrets.QUEUES_UI_PASS }}"
            [ -n "${{ secrets.TZ }}" ] && update_env_var "TZ" "${{ secrets.TZ }}"
            
            # Siempre production
            update_env_var "NODE_ENV" "production"

            # Instalar Docker si no estÃ¡ instalado
            if ! command -v docker &> /dev/null; then
              echo "ðŸ³ Instalando Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              sudo usermod -aG docker $USER
              rm get-docker.sh
            fi
            
            # Detectar quÃ© versiÃ³n de docker-compose usar
            if docker compose version &> /dev/null; then
              COMPOSE_CMD="docker compose"
            elif command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              echo "âŒ Error: Docker Compose no estÃ¡ instalado"
              exit 1
            fi
            echo "ðŸ³ Usando: $COMPOSE_CMD"
            
            # Verificar que Redis estÃ© accesible
            echo "ðŸ” Verificando Redis..."
            if sudo docker run --rm --network host redis:7-alpine redis-cli -h localhost -p 6379 -n 5 PING 2>/dev/null | grep -q PONG; then
              echo "âœ… Redis accesible desde Docker"
            else
              echo "âš ï¸ Advertencia: No se pudo verificar Redis desde contenedor"
            fi
            
            # Construir imÃ¡genes Docker CON los build args para NEXT_PUBLIC_*
            echo "ðŸ”¨ Construyendo imÃ¡genes Docker..."
            
            # Cargar solo las variables necesarias para build-args (evita problemas con caracteres especiales)
            NEXT_PUBLIC_BASE_URL=$(grep '^NEXT_PUBLIC_BASE_URL=' .env | cut -d'=' -f2- | tr -d '"' | tr -d "'")
            NEXTAUTH_URL=$(grep '^NEXTAUTH_URL=' .env | cut -d'=' -f2- | tr -d '"' | tr -d "'")
            DATABASE_URL=$(grep '^DATABASE_URL=' .env | cut -d'=' -f2- | tr -d '"' | tr -d "'")
            
            echo "ðŸ”§ Build args: NEXT_PUBLIC_BASE_URL=$NEXT_PUBLIC_BASE_URL"
            
            sudo $COMPOSE_CMD build --no-cache \
              --build-arg NEXT_PUBLIC_BASE_URL="${NEXT_PUBLIC_BASE_URL}" \
              --build-arg NEXTAUTH_URL="${NEXTAUTH_URL}" \
              --build-arg DATABASE_URL="${DATABASE_URL}"
            
            echo "ðŸš€ Levantando servicios..."
            sudo $COMPOSE_CMD up -d --remove-orphans app worker queues-ui
            
            # Ejecutar migraciones
            echo "ðŸ—„ï¸ Ejecutando migraciones de base de datos..."
            sudo $COMPOSE_CMD run --rm app npx prisma migrate deploy
            
            # Verificar que los contenedores estÃ©n corriendo
            echo "âœ… Verificando contenedores..."
            sudo $COMPOSE_CMD ps
            
            # Verificar health check
            echo "ðŸ¥ Verificando health check..."
            sleep 5
            if curl -f http://localhost:3012/api/health > /dev/null 2>&1; then
              echo "âœ… Health check OK"
            else
              echo "âš ï¸ Health check fallÃ³ (puede ser normal si la app aÃºn estÃ¡ iniciando)"
            fi
            
            # Recargar Apache/Nginx
            echo "ðŸ”„ Recargando web server..."
            sudo systemctl reload apache2 2>/dev/null || sudo systemctl reload nginx 2>/dev/null || echo "âš ï¸ Web server reload skipped"
            
            # Limpiar imÃ¡genes antiguas
            echo "ðŸ§¹ Limpiando imÃ¡genes antiguas..."
            sudo docker image prune -f > /dev/null 2>&1 || true
            
            echo "âœ… Deploy completado exitosamente!"
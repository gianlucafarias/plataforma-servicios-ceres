name: Deploy

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to VPS via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT }}
          command_timeout: 30m
          script: |
            set -e
            echo "üöÄ Iniciando deploy..."
            
            cd /var/www/plataforma-servicios-ceres
            
            # Detectar IP del gateway de Docker para Redis
            DOCKER_GATEWAY_IP=$(docker network inspect bridge --format '{{range .IPAM.Config}}{{.Gateway}}{{end}}' 2>/dev/null || echo "172.17.0.1")
            echo "üîç Gateway de Docker: $DOCKER_GATEWAY_IP"
            
            # Si existe un .env, hacer backup (el .env NO est√° en git, as√≠ que no se borra con git reset)
            if [ -f .env ]; then
              echo "üìã Backup del .env existente..."
              cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
            fi
            
            # Pull cambios de Git PRIMERO
            echo "üì• Obteniendo cambios de Git..."
            git fetch origin main && git reset --hard origin/main
            
            # Funci√≥n para actualizar o agregar variable en .env
            update_env_var() {
              local key=$1
              local value=$2
              if [ -f .env ] && grep -q "^${key}=" .env; then
                sed -i "s|^${key}=.*|${key}=${value}|" .env
              else
                echo "${key}=${value}" >> .env
              fi
            }
            
            # Actualizar variables desde GitHub Secrets
            echo "üìù Actualizando .env desde GitHub Secrets..."
            
            # Variables cr√≠ticas para build y runtime
            [ -n "${{ secrets.DATABASE_URL }}" ] && update_env_var "DATABASE_URL" "${{ secrets.DATABASE_URL }}"
            [ -n "${{ secrets.NEXTAUTH_URL }}" ] && update_env_var "NEXTAUTH_URL" "${{ secrets.NEXTAUTH_URL }}"
            [ -n "${{ secrets.NEXTAUTH_SECRET }}" ] && update_env_var "NEXTAUTH_SECRET" "${{ secrets.NEXTAUTH_SECRET }}"
            [ -n "${{ secrets.NEXT_PUBLIC_BASE_URL }}" ] && update_env_var "NEXT_PUBLIC_BASE_URL" "${{ secrets.NEXT_PUBLIC_BASE_URL }}"
            
            # SMTP
            [ -n "${{ secrets.SMTP_HOST }}" ] && update_env_var "SMTP_HOST" "${{ secrets.SMTP_HOST }}"
            [ -n "${{ secrets.SMTP_PORT }}" ] && update_env_var "SMTP_PORT" "${{ secrets.SMTP_PORT }}"
            [ -n "${{ secrets.SMTP_USER }}" ] && update_env_var "SMTP_USER" "${{ secrets.SMTP_USER }}"
            [ -n "${{ secrets.SMTP_PASS }}" ] && update_env_var "SMTP_PASS" "${{ secrets.SMTP_PASS }}"
            [ -n "${{ secrets.SMTP_FROM }}" ] && update_env_var "SMTP_FROM" "${{ secrets.SMTP_FROM }}"
            
            # Redis
            if [ -n "${{ secrets.REDIS_URL }}" ]; then
              update_env_var "REDIS_URL" "${{ secrets.REDIS_URL }}"
            elif [ ! -f .env ] || ! grep -q "^REDIS_URL=" .env; then
              update_env_var "REDIS_URL" "redis://${DOCKER_GATEWAY_IP}:6379/5"
            fi
            [ -n "${{ secrets.REDIS_PREFIX }}" ] && update_env_var "REDIS_PREFIX" "${{ secrets.REDIS_PREFIX }}"
            
            # OAuth y APIs
            [ -n "${{ secrets.GOOGLE_CLIENT_ID }}" ] && update_env_var "GOOGLE_CLIENT_ID" "${{ secrets.GOOGLE_CLIENT_ID }}"
            [ -n "${{ secrets.GOOGLE_CLIENT_SECRET }}" ] && update_env_var "GOOGLE_CLIENT_SECRET" "${{ secrets.GOOGLE_CLIENT_SECRET }}"
            [ -n "${{ secrets.FACEBOOK_CLIENT_ID }}" ] && update_env_var "FACEBOOK_CLIENT_ID" "${{ secrets.FACEBOOK_CLIENT_ID }}"
            [ -n "${{ secrets.FACEBOOK_CLIENT_SECRET }}" ] && update_env_var "FACEBOOK_CLIENT_SECRET" "${{ secrets.FACEBOOK_CLIENT_SECRET }}"
            [ -n "${{ secrets.ADMIN_API_KEY }}" ] && update_env_var "ADMIN_API_KEY" "${{ secrets.ADMIN_API_KEY }}"
            [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ] && update_env_var "SLACK_WEBHOOK_URL" "${{ secrets.SLACK_WEBHOOK_URL }}"
            [ -n "${{ secrets.QUEUES_UI_PASS }}" ] && update_env_var "QUEUES_UI_PASS" "${{ secrets.QUEUES_UI_PASS }}"
            [ -n "${{ secrets.TZ }}" ] && update_env_var "TZ" "${{ secrets.TZ }}"
            
            # Siempre production
            update_env_var "NODE_ENV" "production"

            # Instalar Docker si no est√° instalado
            if ! command -v docker &> /dev/null; then
              echo "üê≥ Instalando Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              sudo usermod -aG docker $USER
              rm get-docker.sh
            fi
            
            # Detectar qu√© versi√≥n de docker-compose usar
            if docker compose version &> /dev/null; then
              COMPOSE_CMD="docker compose"
            elif command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            else
              echo "‚ùå Error: Docker Compose no est√° instalado"
              exit 1
            fi
            echo "üê≥ Usando: $COMPOSE_CMD"
            
            # Verificar que Redis est√© accesible
            echo "üîç Verificando Redis..."
            if sudo docker run --rm --network host redis:7-alpine redis-cli -h localhost -p 6379 -n 5 PING 2>/dev/null | grep -q PONG; then
              echo "‚úÖ Redis accesible desde Docker"
            else
              echo "‚ö†Ô∏è Advertencia: No se pudo verificar Redis desde contenedor"
            fi
            
            # COMPOSE_PROJECT_NAME asegura que solo toquemos este proyecto
            export COMPOSE_PROJECT_NAME=ceres
            
            # Limpiar SOLO im√°genes viejas de este proyecto
            echo "üßπ Limpiando versiones anteriores de Ceres..."
            sudo docker image prune -f
            
            # Construir imagen √∫nica (solo app)
            NEXT_PUBLIC_BASE_URL=$(grep '^NEXT_PUBLIC_BASE_URL=' .env | cut -d'=' -f2- | tr -d '"' | tr -d "'")
            NEXTAUTH_URL=$(grep '^NEXTAUTH_URL=' .env | cut -d'=' -f2- | tr -d '"' | tr -d "'")
            DATABASE_URL=$(grep '^DATABASE_URL=' .env | cut -d'=' -f2- | tr -d '"' | tr -d "'")
            
            echo "ÔøΩ Construyendo aplicaci√≥n..."
            sudo $COMPOSE_CMD build --no-cache \
              --build-arg NEXT_PUBLIC_BASE_URL="${NEXT_PUBLIC_BASE_URL}" \
              --build-arg NEXTAUTH_URL="${NEXTAUTH_URL}" \
              --build-arg DATABASE_URL="${DATABASE_URL}" app
            
            echo "üöÄ Actualizando servicio..."
            sudo $COMPOSE_CMD up -d --remove-orphans app
            
            # Ejecutar migraciones (ahora tienen todas las librer√≠as)
            echo "üóÑÔ∏è Aplicando cambios en base de datos..."
            sudo $COMPOSE_CMD exec -T app npx prisma migrate deploy
            
            echo "‚úÖ Ceres est√° online!"